---
layout: post
title: "常用算法"
date: "2022-11-19"
categories: 
  - "算法"
---

# 二分法（非递归）

只适合有序排列中查找，二分法的复杂度为$latex O(log\_2N) $

# 分治算法

分而治之，把一个复杂的问题拆分成两个或者更多个相同或者相似的问题，再把子问题分解成更小的子问题，直到最小的子问题可以直接求解，如快速排序。

## 算法步骤

- 分解 ： 将原问题分解成若干个规模更小，相互独立，与原问题形式相同的子问题。
- 解决 ： 如子问题规模较小，则可以直接求解，否则递归的解各个子问题。
- 合并 ： 将各个子问题合并为原问题的解。

 

# 动态规划

跟分治法类似，分治法分解出的子问题是互不相关的，动态规划分解出的子问题是互相关联的。

 

# KMP算法

是暴力匹配算法的优化。

## 暴力匹配算法

- 如果当前字符串匹配成功（即str1\[i\]==str2\[j\]），则i++，j++，继续匹配下一个字符
- 如果不匹配，即str1\[i\]！=str2\[j\]，令i=i-(j-1),j=0。相当于每次匹配失败时，i回溯，j被置为0
- 采用暴力匹配法会有大量的回溯，每次只移动一位，若不匹配，移动到下一位接着判断，这样的算法浪费大量的时间

## KMP算法

KMP算法利用next数组，next数组中保存了模式串中前后最长的公共子序列的长度。每次回溯时。通过next数组找到找到最大后移位置

 

# 贪心算法

概念：贪心算法（贪婪算法）在对问题求解时，在每一步中都选择最好或者最优（即最有利）的选择，从而希望能够导致的结果是最好的或者最优的。

note：贪心算法所得到的结果不一定是最优的结果（有时候会是最优解），但都是对近似（接近）最优解的结果。

 

# 普利姆算法

普利姆算法本质上是求最小生成树（Minimum Cost Spanning Tree）MST,也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含的所有n个顶点的连通子图。

最小生成树：给定一个带权的无向连通图，选取一个生成树，使树上所有边上权的总和为最小。

1. 设G=（V,E）是连通网，T=（U，D）是最小生成树，V,U是顶点的集合，E,D是边的集合
2. 若从顶点u开始构造最小生成树，则从集合v中取出顶点u放入集合U中，并标记顶点visited\[u\]=1
3. 若集合U中的顶点ui与集合V-U中的顶点vi存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入到集合D中，并标记visited\[vj\]=1
4. 重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边

# 克鲁斯卡尔算法

定义：克鲁斯卡尔（Kruskal）算法是用来求加权连通图的最小生成树的算法，它是按照权值从小到大的选择选择（n-1）条边并且不构成回路。

 

# 克鲁斯卡尔算法 普利姆算法 区别

从策略上来说，Prim算法是直接查找，多次寻找邻边的权重最小值，而Kruskal是需要先对权重排序后查找的～

所以说，Kruskal在算法效率上是比Prim快的，因为Kruskal只需一次对权重的排序就能找到最小生成树，而Prim算法需要多次对邻边排序才能找到～

# 迪杰斯特拉算法

概念：迪杰斯特拉算法是典型的最短路径算法，用于计算一个结点到其它结点的最短路径。它的主要特点是以起始点为中心向外层层扩展（广度优先搜索的思想），直到扩展到终点为止。

设置出发顶点为v，顶点集合V（v1,v2,vi…）,v到V中顶点的距离构成距离集合Dis，Dis{d1,d2,di…},Dis集合记录着v到图中各个顶点的距离（到自身可以看做是0，v到vi的距离对应为di）

1. 从Dis中选择最小的dis并移除Dis集合，同时移出V集合中对应的顶点vi,此时的v到vi为最短路径
2. 更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留较小的一个（同时也应该更新顶点的前驱结点为vi，表明是通过vi到达的）
3. 重复执行两步步骤，直到最短路径顶点为目标顶点即可结束。

# 弗洛伊德算法

概念：和迪杰斯特拉一样，弗洛伊德算法也是求给定加权图中顶点间最短路径的算法。但是迪杰斯特拉算法是通过选定被访问的结点，求出从出发访问结点到其它顶点的最短路径。而弗洛伊德算法中的每一个顶点都是出发访问点，所以需要将每一个顶点都看做被访问的顶点，求出每一个顶点到其它顶点的最短路径。

设置顶点vi到顶点vk的最短路径已知为Lik,顶点vk到顶点vj的最短路径为Lkj，顶点vi到顶点vj的路径为Lij，则vi到vj的最短路径为min((Lik+Lki),Lij),vk的取值为图中的所有顶点，则可获得vi到vj的最短路径

 

# 马踏棋盘算法

采用回溯的方法进行的，首先确定一个点的所有可以走的点，然后选择一个点（该点的下一步可走的点的数量最少），一直进行回溯，直到走完棋盘上的全部带点。
