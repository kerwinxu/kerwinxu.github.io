---
layout: post
title: "编译原理-语法分析"
date: "2020-02-17"
categories: ["计算机", "编译原理"]
---

# 两种推导

- 最左推导
    - 在最左推导中，总是选择每个句型中的最左非终结符进行替换。
    - 最右规约是最左推导的逆过程。
    - 自顶向下的语法分析
        - 总是选择每个句型中的最左非终结符进行替换。
        - 根据输入流的下一个终结符，选择最左非终结符的一个候选式。
- 最右推导
    - 在最右推导中，总是选择每个句型中的最右非终结符进行替换。
    - 最左规约是最左推导的逆过程
        - 在自底向上的分析中，总是采用最左规约的方式，
            - 最左规约称为规范规约
            - 最右推导称为规范推导

 

# 自顶向下分析

## 定义

- 分析树的顶部（根节点）向底部（叶节点）方向构造分析树。
- 可以看成是从文法开始符号S推导出词串w的过程。

## 选择

- 替换当前句型中的哪个非终结符。
- 用改终结符的哪个候选式进行替换。

## 问题

### 左递归

- 说明
    - $ A \\rightarrow Aa$形式的产生式的文法称为左递归。
        - 产生式的右部第一个非终结符就是产生式的左部，形成无限循环
- 解决
    - 有如下左递归文法 $ A \\rightarrow A\\alpha | \\beta (\\alpha \\ne \\epsilon , \\beta 不以A开头)$
    - 左递归改成右递归 $ A \\rightarrow \\beta A'$ $ A' \\rightarrow \\alpha A' | \\epsilon$

### 左公因子

- 定义：
    - 当同一非终结符的多个候选式存在共同前缀，将导致回溯现象。
- 解决：
    - 提取左公因子

## LL(1)文法

S文法，简单的确定性文法

- 每个产生式的右部都以终结符开始。
    - 不包含空产生式。
- 同一非终结符的各个候选式的首终结符不同。

LL(1)文法

- 有产生式 $ A \\rightarrow \\alpha | \\beta $ 满足下面2个条件
    - $ \\alpha \\beta 均不能推导出 \\epsilon$
    - $ \\alpha \\beta 至多有一个推导出 \\epsilon$

## 两种实现

### 递归下降分析

```
void A(){
    选择A的一个产生式，A -> X1 X2 ... Xk;
    for (i = 1 to k){
        if (Xi 是一个非终结符符号)
            调用过程Xi();
        else if (Xi 等于当前的输入符号 a)
            读入下一个输入字符;
        else /* 发生了一个错误*/;
    }
}
```

如果A的产生式不止一个，那么如上的会测试每一个候选式，会造成回溯，回溯效率很低，所以这里考虑提前看一下接下来的字符是什么，然后选择唯一的A的产生式。

#### 预测分析

是递归下降的一个特例，通过在输入中向前看固定个数的符号来选择正确的A产生式。

预测分析不需要回溯，是一种确定的自顶向下分析方法。

为每一个非终结符做一个函数，来处理。

 

### 非递归的预测分析法

不需要为每个非终结符编写递归下降过程，而是根据预测分析表构造一个自动机，也叫表驱动的预测分析。[![no img]](http://127.0.0.1/?attachment_id=3021)

这个跟有穷自动机类似，不过多了一个栈，起到记忆的作用。下推存储器。这个也叫下推自动机（push down autometa PDA)

这个预测分析表是 Select集合 ，参考文章，[编译原理之First集,Follow集,Select集](http://127.0.0.1/?p=3007)

算法

- 输入 ：  一个串w和文法G的分析表M
- 输出 ： 如果w在L(G)中，输出w的最左推导，否则给出错误提示。
- 方法：
    - 初始，语法分析器的格局
        -  输入缓冲区中有wS,G的开始符号位于栈顶，其下面是$ ,
    - 分析过程
        
        ```
        设置ip使他指向W的第一个符号，其中ip是输入指针。
        令X = 栈顶符号;
        while( X != $) {    //栈不为空
            if ( X  等于 ip所指向的字符a) 执行栈的弹出操作，将ip向前移动一个位置。
            else if ( X 是一个终结符号) error ();
            else if (M[X,a] 是一个报错条目) error();
            else if( M[X,a] = X -> Y1Y2...Yk){
                输出产生式 X -> Y1Y2...Yk; 
                弹出栈顶符号;
                将 Y1,Y2...YK压入栈中，其中Y1位于栈顶;
            }
            令X = 栈顶符号;
        }
        
        ```
        

# 自底向上分析

## 通用框架

- 在对输入串的一次从左到右扫描过程中，语法分析树将0个或者多个输入符号移入到栈的顶端，直到它可以对栈顶的一个文法符号串 $ \\beta $ 进行规约为止。
- 然后将$ \\beta $ 规约为某个产生式的左部。
- 结束条件
    - 语法分析器不断的重复这个循环，直到它检测到一个语法错误，
    - 或者栈中包含了开始符号且输入缓冲区为空。
- 4个动作
    - 移入
        - 将下一个输入符号移到栈的顶端
    - 规约
        - 被规约的符号串的右端必然位于栈顶，语法分析器在栈中确定这个串的左端，并决定用哪个非终结符来替换这个串。
    - 接收
        - 宣布语法分析过程成功完成。
    - 报错
        - 发现一个语法错误，并调用错误恢复子例程。

### 存在的问题

- 错误的识别了句柄

 

## LR分析法

### 基本原理

- 如果正确的识别句柄
    - 句柄是逐渐形成的
        - 用状态表示句柄识别的进展程度

[![no img]](http://127.0.0.1/?attachment_id=3025)

[![no img]](http://127.0.0.1/?attachment_id=3026)

### 算法

[![no img]](http://127.0.0.1/?attachment_id=3027)
