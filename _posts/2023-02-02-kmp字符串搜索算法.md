---
layout: post
title: "KMP字符串搜索算法"
date: "2023-02-02"
categories: 
  - "c-计算机"
  - "算法"
---

# 分析

现在有字符串s和字串t

s="abcdefgab" t="abcdex"。

我们可以看出，两个串前五位字符分别对应相等，只在第六位失配。如果按照暴力匹配是需要依次匹配一遍。但我们通过观察可以看出，子串中六个字母各不相同，s串的首字母和t串的首字母相同，那么就意味着子串t的首字符不可能与母串2-5之间的字符匹配成功，那么这时，暴力匹配中就有一些步骤是完全可以省略的，之后的字符同理可知都能直接跳过。由于就算我们知道了s\[5\]!=t\[5\]，t\[0\]!=t\[5\]，我们也无法确定t\[0\]一定不等于s\[5\]，所以需要保留它们两个匹配的那一次。

- t\[i\]==s\[i\] (i=0,1,2,3,4)                       字符串s和字串的前5个是相同的
- t\[0\]!=t\[j\] (j=1,2,3,4)                            字串的第一个跟第2到5个是不相同的
- 可以推出：t\[0\]!=s\[j\] (j=1,2,3,4)      字串的第一个跟定跟字符串的2-5个是不相同的

通过以上的例子，我们可以看出kmp算法具体是根据什么回溯的，我们也可以看出这样的回溯方式比暴力匹配好在哪里。我们既然是拿子串去匹配母串，那么肯定是指向子串的数字的回溯，也就是说，串中每个对应的next值与母串无关。我们现在可以继续验证字符重复的情况，现在我们有子串

- t="abcabx"

我们首先需要了解两个概念：

- “前缀”和“后缀”。“前缀”指除了最后一个字符之外，一个字符串的全部头部组合。
- “后缀”指除了第一个字符之外，一个字符串的全部尾部组合。
- 最大公共值就是“前缀”和“后缀”的最长的共有元素的长度。

其次，next数组的下标j指向第n位的时候，计算的是前n-1个字符所组成的字符串的最大公共值，因为next数组描述的是字符串在第n位失配时的转移状况，故不考虑第n位。我们可以发现“ab”出现了重复，故x处对应next数组的值为2，即为最大公共值，这也是设next\[0\]=-1带来的好处，更容易理解，更形象。之后若在x处失配，我们可以把整体向后挪动使得挪动之后的第一个ab对应挪动之前第二个ab的位置，继续从c开始往后匹配。

举例：在文本字符串 “ababaababcabcd” 查找模式字符串 “ababcab” （图1中，红色字符代表正在比较的字符）

[![]](http://127.0.0.1/?attachment_id=4996)

这个最大前缀和最大后缀，我的理解是，如果第n个字串不匹配，那么需要回退，那么回退多少呢，比如

ababc，第4个c不匹配。这个最大的前缀是前面的ab，而最大的后缀是后边的ab，那么只要回退到第三个的a就是了，因为后缀的ab跟字符串已经匹配了，
