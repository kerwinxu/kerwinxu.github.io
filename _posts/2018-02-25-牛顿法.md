---
title: "牛顿法"
date: "2018-02-25"
categories: 
  - "数学"
---

目录

- [简单介绍](#简单介绍)
    - 求[方程的根](#求方程的根)
    - [最优化问题](#最优化问题)
- [原理](#原理)
- [求方程根例子](#求方程根例子)
- [牛顿法求最值例子](#牛顿法求最值例子)

# 简单介绍：牛顿法主要应用在2个方面，，求方程的根和最优化。

- ## 求方程的根
    
    。
    - 原理：
        - 根据[泰勒公式](http://127.0.0.1/?p=954) ：$$f(x)=f(x\_0)+(x-x\_0)f'(x\_0)$$
        - 然后令上边公式等于 0 ,也就是f(x)=0，则有  $$x\_1=x\_0-\\frac{f(x\_0)}{f'(x\_0)}$$
        - 然后 $$x\_{n+1}=x\_n-\\frac{f(x\_n)}{f'(x\_n)}$$
    - 原理2 ：
        -  [![](images/1ad5ad6eddc451da7e10e099b6fd5266d11632da.jpg)](http://127.0.0.1/wp-content/uploads/2018/02/1ad5ad6eddc451da7e10e099b6fd5266d11632da.jpg)
        - 我们都是要求f(x)等于0的，也就是在x轴上和曲线的相交处 $latex x^\*$
        - $latex x\_n$为上一个值，而$latex x\_{n+1}$为下一个值，
        - 我们要从 $latex x\_n$到$latex x^\*$，我们可以先到达 $latex x\_{n+1}$
        - 而$latex x\_n-x\_{n+1}=\\frac{f(x\_n)}{f'(x\_n)}$ ，这个就是导数，切线的斜率。
        - 这样迭代下去，直到f(x)小于一个需要的值，就找到了相应的x
        - 牛顿法和[梯度下降法](http://127.0.0.1/?p=824)类似，都是用斜率（求导）的方式减去一个值，然后逼近解的。
- ## 最优化问题
    
    - 最优化问题一般是求最大值最小值问题，这可转化成求导数0点，然后转化为1的情形。
    - 原理：
        - 把[泰勒公式](http://127.0.0.1/?p=954)展开为二阶，$$f(x+\\Delta{x})=f(x)+f'(x)\\Delta{x}+\\frac{1}{2}f''(x)\\Delta{x}^2$$
        - 假设等号左边和f(x)近似相等，抵消掉，然后对 $latex \\Delta{x}$求导。得到 $$f'(x)+f''(x)\\Delta{x}=0$$
        - 更进一步 $$\\Delta{x}=-\\frac{f'(x\_n)}{f''(x\_n)}$$
        - 然后得到迭代因子 $$ x\_{n+1}=x\_{n}-\\frac{f'(x\_n)}{f''(x\_n)},n=0,1,\\cdots$$
    - 解说，
        - [![](images/1ad5ad6eddc451da7e10e099b6fd5266d11632da.jpg)](http://127.0.0.1/wp-content/uploads/2018/02/1ad5ad6eddc451da7e10e099b6fd5266d11632da.jpg)
        - 还是以这个图像，
        - 一阶导数是这个曲线某点的斜率，正切值。
        - 而二阶导数是这个斜率的斜率的，相当于加速度。
    - 解说2
        - 在求方程的根中，是求 f(x)=0解。得到，$$x\_{n+1}=x\_n-\\frac{f(x\_n)}{f'(x\_n)}$$
        - 而在求最值中，是求f'(x)=0的解。得到，$$ x\_{n+1}=x\_{n}-\\frac{f'(x\_n)}{f''(x\_n)},n=0,1,\\cdots$$
        - 我想第二种更容易理解吧。

 

如上是用于一元函数，用于多元函数的可以参考雅克比矩阵和海森矩阵，

将2个矩阵代入，就是 $$x\_{k+1}=x\_k-H^{-1}(x\_k)J\_f(x\_k)$$

 

说明：

```
import numpy as np
import matplotlib.pylab as plb
%matplotlib inline

```

# 原理

根据一级泰勒公式展开

f(x)\=f(x0)+(x−x0)f′(x0)

令上式等于0,则 0\=f(x0)+(x1−x0)f′(x0)

(x1−x0)f′(x0)\=−f(x0)

x1−x0\=−f(x0)f′(x0)

x1\=x0−f(x0)f′(x0)

xn+1\=xn−f(xn)f′(xn)

可以设置 f(x)=0是因为，假设有个方程 f(x)=a_x\*\*3+b_x\*_2+c_x+d ，假设我们要求f(x)=1的解，我们可以将这个1移到方程的另一边去。

假设方程为 f(x)=ax^3+bx\*^2+cx+d 是个三次方程，求f(x)=2的解。为方便计算，我这里设置abcd都是1吧，如果是其他值，计算是同理的。

In \[11\]:

```
def f_old(x):
    # 这个是原先的方程。是要计算这个等于2
     return x**3+x**2+x+1

```

In \[12\]:

```
def f(x):
    # 这个是将f(x)=2一到另一边的，原先的d为1，现在再减去2，等于-1
    return x**3+x**2+x-1

```

In \[13\]:

```
def f1(x):
    return 2*x**2+2*x+1

```

In \[14\]:

```
# 设置初始的x为10吧，很大的一个数字，小于误差0.01就结束。
x0=10 
lost=0.01
fx=f(x0) #由初始的x计算fx
while(fx>lost): #大于误差就继续，反之就是得到了需要的参数
    fx=f(x0)
    x0=x0-fx/f1(x0)
    print("x:{}".format(x0))
    pass
# 让我们看一下找到的这个值是否是需要的
print("f(x):{}".format(f_old(x0)))

```

```
x:4.981900452488688
x:2.4663480879855944
x:1.2202903911053584
x:0.670881613934439
x:0.5404297191049777
x:0.5440566705588258
f(x):2.0010938331553056
```

# 牛顿法求最值例子

```
# 这个用最简单的例子，y=x^2-3x来求最值

```

In \[1\]:

```
x0=10 #初始x还是0，很高吧。
def f_0(x):
    # 原始方程
    return x**2-3*x
def f_1(x):
    # 一阶求导
    return 2*x-3
def f_2(x):
    # 二阶求导
    return 2
lost=0.01 #假设斜率小于0停止。
fx_1=f_1(x0)
while(fx_1>lost):
    fx_1=f_1(x0)
    x0=x0-fx_1/f_2(x0)
    print("x:{}".format(x0))
print("f_0:{}".format(f_0(x0)))

```

```
x:1.5
x:1.5
f_0:-2.25

```

In \[5\]:

Out\[5\]:

```
20
```
