---
layout: post
title: "numpy学习"
date: "2018-02-11"
categories: ["计算机语言", "Python"]
---

```
import numpy as np
print(np.version.version)

```

```
1.14.0

```

# 创建

## 创建一维数组

In \[4\]:

```
np.array([1,2,3,4]) # 以list或tuple变量为参数产生一维数组

```

Out\[4\]:

```
array([1, 2, 3, 4])
```

## 创建二维数组

In \[5\]:

```
np.array([[1,2],[3,4]]) # 只是一维数组的元素为数组。

```

Out\[5\]:

```
array([[1, 2],
       [3, 4]])
```

## 生成数组的时候，可以指定数据类型，例如numpy.int32, numpy.int16, and numpy.float64等：

In \[6\]:

```
np.array((1.2,2,3,4), dtype=np.int32)

```

Out\[6\]:

```
array([1, 2, 3, 4])
```

## 使用numpy.arange方法

In \[7\]:

```
np.arange(15)

```

Out\[7\]:

```
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
```

In \[8\]:

```
np.arange(15).reshape(3,5)

```

Out\[8\]:

```
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
```

## 使用numpy.linspace方法,从这个数到那个数之间产生几个数字

In \[9\]:

```
np.linspace(1,3,9)

```

Out\[9\]:

```
array([1. , 1.25, 1.5 , 1.75, 2. , 2.25, 2.5 , 2.75, 3. ])
```

In \[10\]:

```
np.linspace(1,10,10)

```

Out\[10\]:

```
array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])
```

## 构造特定的矩阵。

In \[11\]:

```
np.zeros((3,5))

```

Out\[11\]:

```
array([[0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.]])
```

In \[12\]:

```
np.zeros((2,3,4))

```

Out\[12\]:

```
array([[[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]],

       [[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]]])
```

In \[13\]:

```
np.ones((3,5))

```

Out\[13\]:

```
array([[1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.]])
```

In \[14\]:

```
np.eye(3)

```

Out\[14\]:

```
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
```

In \[15\]:

```
np.eye(5)

```

Out\[15\]:

```
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
```

## 用随机数创建

# 获得对象的属性

In \[16\]:

```
 a = np.zeros((2,2,2))

```

In \[17\]:

```
a.ndim #维数

```

Out\[17\]:

```
3
```

In \[18\]:

```
a.shape # 每一维的大小

```

Out\[18\]:

```
(2, 2, 2)
```

In \[19\]:

```
a.size

```

Out\[19\]:

```
8
```

In \[20\]:

```
a.dtype

```

Out\[20\]:

```
dtype('float64')
```

In \[21\]:

```
a.itemsize # 每个元素所占的字节数

```

Out\[21\]:

```
8
```

# 数组切片、索引、赋值

In \[22\]:

```
a = np.array( [[2,3,4],[5,6,7]] )

```

In \[23\]:

```
a[1,2]

```

Out\[23\]:

```
7
```

In \[24\]:

```
a[1,:]

```

Out\[24\]:

```
array([5, 6, 7])
```

In \[25\]:

```
a[1,1:2]

```

Out\[25\]:

```
array([6])
```

In \[26\]:

```
a[1,:] = [8,9,10]
a

```

Out\[26\]:

```
array([[ 2,  3,  4],
       [ 8,  9, 10]])
```

# 数组的基本运算

In \[27\]:

```
a = np.ones((2,2))
b = np.eye(2)
print("a:\n{}".format(a))
print("b:\n{}".format(b))

```

```
a:
[[1. 1.]
 [1. 1.]]
b:
[[1. 0.]
 [0. 1.]]

```

In \[28\]:

```
b>0

```

Out\[28\]:

```
array([[ True, False],
       [False,  True]])
```

In \[29\]:

```
a+b

```

Out\[29\]:

```
array([[2., 1.],
       [1., 2.]])
```

In \[30\]:

```
a-b

```

Out\[30\]:

```
array([[0., 1.],
       [1., 0.]])
```

In \[31\]:

```
b*2

```

Out\[31\]:

```
array([[2., 0.],
       [0., 2.]])
```

In \[32\]:

```
(a+2)*(b+2)

```

Out\[32\]:

```
array([[9., 6.],
       [6., 9.]])
```

In \[33\]:

```
b*2**4

```

Out\[33\]:

```
array([[16.,  0.],
       [ 0., 16.]])
```

# 数组自带的方法

In \[34\]:

```
a.sum()

```

Out\[34\]:

```
4.0
```

In \[35\]:

```
a.sum(axis=0)   #计算每一列（二维数组中类似于矩阵的列）的和

```

Out\[35\]:

```
array([2., 2.])
```

In \[36\]:

```
a.min()

```

Out\[36\]:

```
1.0
```

In \[37\]:

```
a.max()

```

Out\[37\]:

```
1.0
```

# numpy的方法

In \[75\]:

```
a=np.array([[1,2],[3,4]])

```

## 三角函数方法

In \[76\]:

```
np.sin(a)

```

Out\[76\]:

```
array([[ 0.84147098,  0.90929743],
       [ 0.14112001, -0.7568025 ]])
```

## 数值计算方法

In \[78\]:

```
np.floor(a)

```

Out\[78\]:

```
array([[1., 2.],
       [3., 4.]])
```

In \[85\]:

```
 np.exp(a) # e^x

```

Out\[85\]:

```
array([[ 2.71828183,  7.3890561 ],
       [20.08553692, 54.59815003]])
```

In \[86\]:

```
 np.dot(a,b)   ##矩阵乘法

```

Out\[86\]:

```
array([[1., 2.],
       [3., 4.]])
```

In \[87\]:

```
np.abs(a) # 绝对值

```

Out\[87\]:

```
array([[1, 2],
       [3, 4]])
```

In \[88\]:

```
np.fabs(a) # 复数的绝对值

```

Out\[88\]:

```
array([[1., 2.],
       [3., 4.]])
```

In \[89\]:

```
np.sqrt(a) # 平方根

```

Out\[89\]:

```
array([[1. , 1.41421356],
       [1.73205081, 2. ]])
```

In \[90\]:

```
np.square(a) # 平方

```

Out\[90\]:

```
array([[ 1,  4],
       [ 9, 16]], dtype=int32)
```

## 合并数组

In \[43\]:

```
a = np.ones((2,2))
b = np.eye(2)

```

In \[44\]:

```
np.vstack((a,b)) # 竖直合并

```

Out\[44\]:

```
array([[1., 1.],
       [1., 1.],
       [1., 0.],
       [0., 1.]])
```

In \[45\]:

```
np.hstack((a,b))  # 水平合并

```

Out\[45\]:

```
array([[1., 1., 1., 0.],
       [1., 1., 0., 1.]])
```

## 数学统计方法

In \[96\]:

```
arr=np.random.randint(1,20,10)
arr

```

Out\[96\]:

```
array([ 6,  3,  6,  5,  4,  4,  9, 11,  2, 14])
```

In \[97\]:

```
arr.sum()

```

Out\[97\]:

```
64
```

In \[98\]:

```
arr.mean()

```

Out\[98\]:

```
6.4
```

In \[99\]:

```
arr.std()  # 标准差

```

Out\[99\]:

```
3.6110940170535577
```

In \[100\]:

```
arr.var()  ## 方差

```

Out\[100\]:

```
13.040000000000001
```

In \[102\]:

```
arr.min()

```

Out\[102\]:

```
2
```

In \[103\]:

```
arr.max()

```

Out\[103\]:

```
14
```

In \[104\]:

```
arr.argmin()

```

Out\[104\]:

```
8
```

In \[105\]:

```
arr.argmax()

```

Out\[105\]:

```
9
```

In \[106\]:

```
arr.cumsum() # 所有元素的累计和，

```

Out\[106\]:

```
array([ 6,  9, 15, 20, 24, 28, 37, 48, 50, 64], dtype=int32)
```

In \[108\]:

```
arr.cumprod() # 所有元素的累计乘积

```

Out\[108\]:

```
array([       6,       18,      108,      540,     2160,     8640,
          77760,   855360,  1710720, 23950080], dtype=int32)
```

# 拷贝方法

## 浅拷贝

In \[47\]:

```
a = np.ones((2,2))
b = a
b is a

```

Out\[47\]:

```
True
```

## 深拷贝

In \[49\]:

```
c = a.copy()  #深拷贝
c is a

```

Out\[49\]:

```
False
```

# 其他数组方法

In \[109\]:

```
arr=np.random.randint(1,20,10)
arr

```

Out\[109\]:

```
array([17, 16, 11,  3, 13, 15, 12,  9, 15, 17])
```

In \[112\]:

```
arr.sort()
arr

```

Out\[112\]:

```
array([ 3,  9, 11, 12, 13, 15, 15, 16, 17, 17])
```

# 矩阵运算

In \[56\]:

```
a = np.array([[1,0],[2,3]])
import numpy.linalg as nplg
# 在numoy中存在dnarray和matrix2种可以表示矩阵的。
# 其中matrix意思是矩阵，但是ndarray也可以用来处理矩阵，
# 只是如果用ndarray。那么的用dot函数之类的来表示乘积。

```

## 转置

In \[54\]:

```
a.transpose()

```

Out\[54\]:

```
array([[1, 2],
       [0, 3]])
```

In \[55\]:

```
a.T

```

Out\[55\]:

```
array([[1, 2],
       [0, 3]])
```

## 乘积

In \[113\]:

```
a = np.ones((2,2))
b = np.eye(2)

```

In \[114\]:

```
print(a)
print(b)

```

```
[[1. 1.]
 [1. 1.]]
[[1. 0.]
 [0. 1.]]

```

In \[115\]:

```
a*b # 这个不是矩阵乘积，仅仅是相同下标的向量乘积。，比如a的第一行第一列乘以b的第一行第一列

```

Out\[115\]:

```
array([[1., 0.],
       [0., 1.]])
```

In \[116\]:

```
a.dot(b) # 这个才是阵阵过的矩阵乘积

```

Out\[116\]:

```
array([[1., 1.],
       [1., 1.]])
```

In \[117\]:

```
np.dot(a,b) # 这个才是阵阵过的矩阵乘积

```

Out\[117\]:

```
array([[1., 1.],
       [1., 1.]])
```

## 矩阵求逆运算

In \[119\]:

```
nplg.inv(b)

```

Out\[119\]:

```
array([[1., 0.],
       [0., 1.]])
```

## 解线性方程

In \[120\]:

```
a = np.array([[3,1], [1,2]])
a

```

Out\[120\]:

```
array([[3, 1],
       [1, 2]])
```

In \[121\]:

```
b = np.array([9,8])
b

```

Out\[121\]:

```
array([9, 8])
```

In \[122\]:

```
x = np.linalg.solve(a, b)

```

In \[123\]:

```
x

```

Out\[123\]:

```
array([2., 3.])
```

In \[124\]:

```
print("也就是说这个方程是y={}*x+{}".format(x[0],x[1]))

```

```
也就是说这个方程是y=2.0*x+3.0

```

## 计算线性回归中的最小二乘解

### 根据提供的api计算 （np.linalg.lstsq）

In \[ \]:

```
# y = mx + c 

```

In \[138\]:

```
x = np.array([0, 1, 2, 3])
y = np.array([-1, 0.2, 0.9, 2.1])

```

In \[176\]:

```
np.ones(len(x))

```

Out\[176\]:

```
array([1., 1., 1., 1.])
```

In \[177\]:

```
[x,np.ones(len(x))]

```

Out\[177\]:

```
[array([0, 1, 2, 3]), array([1., 1., 1., 1.])]
```

In \[179\]:

```
np.vstack([x,np.ones(len(x))])

```

Out\[179\]:

```
array([[0., 1., 2., 3.],
       [1., 1., 1., 1.]])
```

In \[180\]:

```
np.vstack([x, np.ones(len(x))]).T # 把一个列表转换成矩阵的形式，且要加上一项系数的

```

Out\[180\]:

```
array([[0., 1.],
       [1., 1.],
       [2., 1.],
       [3., 1.]])
```

In \[139\]:

```
# 需要把这个变成矩阵形式。

```

In \[140\]:

```
A = np.vstack([x, np.ones(len(x))]).T
A

```

Out\[140\]:

```
array([[0., 1.],
       [1., 1.],
       [2., 1.],
       [3., 1.]])
```

In \[152\]:

```
m, c = np.linalg.lstsq(A, y,rcond=None)[0]

```

In \[153\]:

```
print("m:{} , c:{}".format(m,c))

```

```
m:0.9999999999999999 , c:-0.9499999999999997

```

### 手动计算最小二乘数。 公式 \[Math Processing Error\]β^\=XTyXTX

In \[156\]:

```
nplg.inv(A.T.dot(A)).dot(A.T.dot(y.T))

```

Out\[156\]:

```
array([ 1. , -0.95])
```

# 自定义func方法。

In \[157\]:

```
"""
将一些只对单一值操作的函数（以下称标量函数）进行转换，得到对应的ufunc，可以使用numpy中的两个函数：frompyfunc和vectorize


np.frompyfunc(func, nin, nout)函数需要指定三个参数，依次为：标量函数、输入参数个数、返回值个数；

np.frompyfunc的返回值其类型均为object，通过astype()方法可以将类型做出相应的转换；


np.vectorize(func, otypes=[])函数指定两个参数，依次为：标量参数、返回值的类型列表；
"""

```

Out\[157\]:

```
'\n将一些只对单一值操作的函数（以下称标量函数）进行转换，得到对应的ufunc，可以使用numpy中的两个函数：frompyfunc和vectorize\n\n\nnp.frompyfunc(func, nin, nout)函数需要指定三个参数，依次为：标量函数、输入参数个数、返回值个数；\n\nnp.frompyfunc的返回值其类型均为object，通过astype()方法可以将类型做出相应的转换；\n\n\nnp.vectorize(func, otypes=[])函数指定两个参数，依次为：标量参数、返回值的类型列表；\n'
```

In \[169\]:

```
import math
x = np.array([0, 1, 2, 3])

```

In \[170\]:

```
def my_sin(x):
    return math.sin(x)
my_np_sin=np.vectorize(my_sin)

```

In \[172\]:

```
my_np_sin(x)

```

Out\[172\]:

```
array([0. , 0.84147098, 0.90929743, 0.14112001])
```

In \[173\]:

```
my_np_sin_2=np.frompyfunc(my_sin,1,1)

```

In \[174\]:

```
my_np_sin_2(x)

```

Out\[174\]:

```
array([0.0, 0.8414709848078965, 0.9092974268256817, 0.1411200080598672],
      dtype=object)
```

In \[175\]:

```
# 可以看到如上2个函数的作用是差不多的，只是一个可以选择输出参数的个数而已。
```
