---
layout: post
title: "设计模式分类总结"
date: "2020-03-01"
categories: 
  - "设计模式"
---

# 设计原则

原则、依赖倒置原则、接口隔离原则、合成复用原则和迪米特法则。下面就分别介绍了每种设计原则。

## 单一职责原则

就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性。

## 开闭原则(Open-Closed Principle)

开闭原则即OCP（Open-Closed Principle缩写）原则，该原则强调的是：一个软件实体（指的类、函数、模块等）应该对扩展开放，对修改关闭。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。

符合开闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。

## 里氏代替原则(Liskov Substitution Principle)

Liskov Substitution Principle,LSP（里氏代替原则）指的是子类必须替换掉它们的父类型。也就是说，在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后，此时软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。为了就来看看违反了LSP原则的例子，具体代码如下所示：

```
public class Rectangle
    {
        public virtual long Width { get; set; }
        public virtual long Height { get; set; }
    }
    // 正方形
    public class Square : Rectangle
    {
        public override long Height
        {
            get
            {
                return base.Height;
            }
            set
            {
                base.Height = value;
                base.Width = value;
            }
        }

        public override long Width
        {
            get
            {
                return base.Width;
            }
            set
            {
                base.Width = value;
                base.Height = value;
            }
        }
    }
 class Test
    {
        public void Resize(Rectangle r)
        {
            while (r.Height >= r.Width)
            {
                r.Width += 1;
            }
        }
        var r = new Square() { Width = 10, Height = 10 };
         new Test().Resize(r);
     }
```

上面的设计，正如上面注释的一样，在执行SmartTest的resize方法时，如果传入的是长方形对象，当高度大于宽度时，会自动增加宽度直到超出高度。但是如果传入的是正方形对象，则会陷入死循环。此时根本原因是，矩形不能作为正方形的父类，既然出现了问题，可以进行重构，使它们俩都继承于四边形类。重构后的代码如下所示：

```
// 四边形
    public abstract class Quadrangle
    {
        public virtual long Width { get; set; }
        public virtual long Height { get; set; }
    }
    // 矩形
    public class Rectangle : Quadrangle
    {
        public override long Height { get; set; }

        public override long Width { get; set; }
       
    }
    // 正方形
    public class Square : Quadrangle
    {
        public long _side;

        public Square(long side)
        {
            _side = side;
        }
    }
 class Test
    {
        public void Resize(Quadrangle r)
        {
            while (r.Height >= r.Width)
            {
                r.Width += 1;
            }
        }


        static void Main(string[] args)
        {
            var s = new Square(10);

            new Test().Resize(s);
        }
    }
```

 

## 依赖倒置原则

依赖倒置（Dependence Inversion Principle, DIP）原则指的是抽象不应该依赖于细节，细节应该依赖于抽象，也就是提出的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。

## 接口隔离原则

接口隔离原则（Interface Segregation Principle, ISP）指的是使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。

## 合成复用原则

合成复用原则（Composite Reuse Principle, CRP）就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。

要使用好合成复用原则，首先需要区分"Has—A"和“Is—A”的关系。

“Is—A”是指一个类是另一个类的“一种”，是属于的关系，而“Has—A”则不同，它表示某一个角色具有某一项责任。导致错误的使用继承而不是聚合的常见的原因是错误地把“Has—A”当成“Is—A”.例如：

- IS-A表示继承。父类与子类，具有很高的耦合度。
- HAS-A表示组合。是整体与部分的关系，同时它们的生命周期都是一样的
- USE-A表示依赖。依然是其中一个拥有另外一个，但是不负责销毁，也就是声明周期不一样

[![]](http://127.0.0.1/?attachment_id=3974)

实际上，雇员、经历、学生描述的是一种角色，比如一个人是“经理”必然是“雇员”。在上面的设计中，一个人无法同时拥有多个角色，是“雇员”就不能再是“学生”了，这显然不合理，因为现在很多在职研究生，即使雇员也是学生。

上面的设计的错误源于把“角色”的等级结构与“人”的等级结构混淆起来了，误把“Has—A”当作"Is—A"。具体的解决方法就是抽象出一个角色类：

[![]](http://127.0.0.1/?attachment_id=3975)

## 迪米特法则

迪米特法则（Law of Demeter，LoD）又叫最少知识原则（Least Knowledge Principle，LKP），指的是一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。

关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。

外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。

# 创建型模式

创建型模式就是用来创建对象的模式，抽象了实例化的过程。所有的创建型模式都有两个共同点。第一，它们都将系统使用哪些具体类的信息封装起来；第二，它们隐藏了这些类的实例是如何被创建和组织的。创建型模式包括单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式。

- [简单工厂模式](http://127.0.0.1/?p=2485) ： 有一个工厂类负责创建各个对象。
- [工厂方法模式](http://127.0.0.1/?p=2487) ： 有一个抽象的工厂，然后从抽象的工厂继承的具体的工厂负责具体的产品创建。
    - 工厂和产品类是平行的关系
- [抽象工厂模式](http://127.0.0.1/?p=2494) ： 提供一个创建产品的接口来负责创建相关或依赖的对象，而不具体明确指明具体类。
    - 一个工厂创建一组平行的产品。
- [建造者模式](http://127.0.0.1/?p=2504) ： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    - 主要目的是通过组装零配件组成一个新的产品。
- [原型模式](http://127.0.0.1/?p=2509) ：  用于创建重复的对象。
- [单例模式](http://127.0.0.1/?p=2481) ： 保证一个类只有一个实例。

## [单例模式](http://127.0.0.1/?p=2481)

单例模式是保证一个类只有一个实例，并提供一个全局访问点。

实现要点

- 只有一个实例，如何保证。
    - 通过私有的构造函数来保证类外部不能对类实现实例化。
- 提供一个全局访问点，如何实现。
    - 类的静态方法。

[![]](http://127.0.0.1/?attachment_id=3976)

## [工厂方法模式](http://127.0.0.1/?p=2487)

定义一个创建对象的工厂接口，由其子类来决定要实例化的类，将实际的创建工作推迟到子类中。

要点

- 定义一个工厂接口，如何实现。
    - 声明一个工厂抽象类。
- 由其具体子类创建对象，如何实现。
    - 创建派生于抽象工厂类的具体工厂来创建产品。

[![]](http://127.0.0.1/?attachment_id=3977)

在工厂方法模式中，工厂类与具体的产品类具有平行的等级关系，他们之间是一一对应关系。

## [抽象工厂模式](http://127.0.0.1/?p=2494)

提供一个创建一系列相关或依赖对象的接口，使得客户端可以在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象，强调的是”系列对象“的变化。

实现要点：

- 创建一系列对象的接口，如何实现。
    - 提供多个产品的抽象接口。
- 创建多个产品族中的多个产品对象，如果做到。
    - 每个具体工厂创建一个产品族中的多个产品对象，多个具体工厂就可以创建多个产品族中的对象了。

[![]](http://127.0.0.1/?attachment_id=3978)

## [建造者模式](http://127.0.0.1/?p=2504)

建造者模式指的是将一个产品的内部表示与产品的构造过程分割开来，从而可以使一个建造过程生成具体不同的内部表示的产品对象。强调的是产品的构造过程。

实现要点有：

- 将产品的内部表示与产品的构造过程分割开来。问：如何把它们分割开呢？
    - 答：不要把产品的构造过程放在产品类中，而是由建造者类来负责构造过程，产品的内部表示放在产品类中，这样不就分割开了嘛。

[![]](http://127.0.0.1/?attachment_id=3979)

## [原型工厂模式](http://127.0.0.1/?p=2509)

原型模式指的是通过给出一个原型对象来指明所要创建的对象类型，然后用复制的方法来创建出更多的同类型对象。

实现要点：

- 给出一个原型对象。问：如何办到呢？
    - 答：很简单嘛，直接给出一个原型类就好了。
- 通过复制的方法来创建同类型对象。问：又是如何实现呢？
    - 答：.NET可以直接调用MemberwiseClone方法来实现浅拷贝

[![]](http://127.0.0.1/?attachment_id=3980)

# 结构性模式

结构型模式，顾名思义讨论的是类和对象的结构 ，主要用来处理类或对象的组合。它包括两种类型，一是类结构型模式，指的是采用继承机制来组合接口或实现；二是对象结构型模式，指的是通过组合对象的方式来实现新的功能。它包括适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式和代理模式。

- [适配器模式](http://127.0.0.1/?p=2516) ： 注重转换接口，将不吻合的接口适配对象。
- [桥接模式](http://127.0.0.1/?p=2521) ： 注重分类接口于其实现，支持多维度变化。
- [组合模式](http://127.0.0.1/?p=2526) ： 注重统一接口，将一对多的关系转化为一对一的关系。
- [装饰模式](http://127.0.0.1/?p=2448) ： 注重稳定接口，在此前提下为对象扩展功能。
- [外观模式](http://127.0.0.1/?p=2533) ： 注重简化接口，简化组件系统与外部客户程序的依赖关系。
- [享元模式](http://127.0.0.1/?p=2538) ： 注重保留接口，在内部使用共享技术对对象存储进行优化。
- [代理模式](http://127.0.0.1/?p=2542) ： 注重假借接口，增加间接层来实现灵活控制。

## [适配器模式](http://127.0.0.1/?p=2516)

适配器模式意在转换接口，它能够使原本不能再一起工作的两个类一起工作，所以经常用来在类库的复用、代码迁移等方面。例如DataAdapter类就应用了适配器模式。适配器模式包括类适配器模式和对象适配器模式，具体结构如下图所示，左边是类适配器模式，右边是对象适配器模式。

[![]](http://127.0.0.1/?attachment_id=3981)

## [桥接模式](http://127.0.0.1/?p=2521)

桥接模式旨在将抽象化与实现化解耦，使得两者可以独立地变化。意思就是说，桥接模式把原来基类的实现化细节再进一步进行抽象，构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度的独立变化，桥接模式的结构图如下所示。

[![]](http://127.0.0.1/?attachment_id=3982)

## [装饰者模式](http://127.0.0.1/?p=2448)

装饰者模式又称包装（Wrapper）模式，它可以动态地给一个对象添加一些额外的功能，装饰者模式较继承生成子类的方式更加灵活。虽然装饰者模式能够动态地将职责附加到对象上，但它也会造成产生一些细小的对象，增加了系统的复杂度。具体的结构图如下所示。

[![]](http://127.0.0.1/?attachment_id=3983)

## [组合模式](http://组合模式)

组合模式又称为部分—整体模式。组合模式将对象组合成树形结构，用来表示整体与部分的关系。组合模式使得客户端将单个对象和组合对象同等对待。如在.NET中WinForm中的控件，TextBox、Label等简单控件继承与Control类，同时GroupBox这样的组合控件也是继承于Control类。组合模式的具体结构图如下所示。

[![]](http://127.0.0.1/?attachment_id=3984)

## [外观模式](http://127.0.0.1/?p=2533)

在系统中，客户端经常需要与多个子系统进行交互，这样导致客户端会随着子系统的变化而变化，此时可以使用外观模式把客户端与各个子系统解耦。外观模式指的是为子系统中的一组接口提供一个一致的门面，它提供了一个高层接口，这个接口使子系统更加容易使用。如电信的客户专员，你可以让客户专员来完成冲话费，修改套餐等业务，而不需要自己去与各个子系统进行交互。具体类结构图如下所示：

[![]](http://127.0.0.1/?attachment_id=3985)

## [享元模式](http://127.0.0.1/?p=2538)

在系统中，如何我们需要重复使用某个对象时，此时如果重复地使用new操作符来创建这个对象的话，这对系统资源是一个极大的浪费，既然每次使用的都是同一个对象，为什么不能对其共享呢？这也是享元模式出现的原因。

享元模式运用共享的技术有效地支持细粒度的对象，使其进行共享。在.NET类库中，String类的实现就使用了享元模式，String类采用字符串驻留池的来使字符串进行共享。更多内容参考博文：[http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html](http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html)。享元模式的具体结构图如下所示。

[![]](http://127.0.0.1/?attachment_id=3986)

## [代理模式](http://127.0.0.1/?p=2542)

在系统开发中，有些对象由于网络或其他的障碍，以至于不能直接对其访问，此时可以通过一个代理对象来实现对目标对象的访问。如.NET中的调用Web服务等操作。

代理模式指的是给某一个对象提供一个代理，并由代理对象控制对原对象的访问。具体的结构图如下所示。

[![]](http://127.0.0.1/?attachment_id=3987)

注：外观模式、适配器模式和代理模式区别？

解答：这三个模式的相同之处是，它们都是作为客户端与真实被使用的类或系统之间的一个中间层，起到让客户端间接调用真实类的作用，不同之处在于，所应用的场合和意图不同。

代理模式与外观模式主要区别在于，代理对象无法直接访问对象，只能由代理对象提供访问，而外观对象提供对各个子系统简化访问调用接口，而适配器模式则不需要虚构一个代理者，目的是复用原有的接口。外观模式是定义新的接口，而适配器则是复用一个原有的接口。

另外，它们应用设计的不同阶段，外观模式用于设计的前期，因为系统需要前期就需要依赖于外观，而适配器应用于设计完成之后，当发现设计完成的类无法协同工作时，可以采用适配器模式。然而很多情况下在设计初期就要考虑适配器模式的使用，如涉及到大量第三方应用接口的情况；代理模式是模式完成后，想以服务的方式提供给其他客户端进行调用，此时其他客户端可以使用代理模式来对模块进行访问。

总之，

- **代理模式提供与真实类一致的接口，旨在用来代理类来访问真实的类，**
- **外观模式旨在简化接口，**
- **适配器模式旨在转换接口。**

# 行为模式

行为模式是对在不同对象之间划分责任和算法的抽象化。行为模式不仅仅关于类和对象，还关于它们之间的相互作用。行为型模式又分为类的行为模式和对象的行为模式两种。

- 类的行为模式——使用继承关系在几个类之间分配行为。
- 对象的行为模式——使用对象聚合的方式来分配行为。

行为型模式包括11种模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、状态模式、策略模式、责任链模式、访问者模式、解释器模式和备忘录模式。

- [模板方法模式](http://127.0.0.1/?p=2546)：封装算法结构，定义算法骨架，支持算法子步骤变化。
- [命令模式](http://127.0.0.1/?p=2554)：注重将请求封装为对象，支持请求的变化，通过将一组行为抽象为对象，实现行为请求者和行为实现者之间的解耦。
- [迭代器模式](http://127.0.0.1/?p=2559)：注重封装特定领域变化，支持集合的变化，屏蔽集合对象内部复杂结构，提供客户程序对它的透明遍历。
- [观察者模式](http://127.0.0.1/?p=2563)：注重封装对象通知，支持通信对象的变化，实现对象状态改变，通知依赖它的对象并更新。
- [中介者模式](http://127.0.0.1/?p=2567)：注重封装对象间的交互，通过封装一系列对象之间的复杂交互，使他们不需要显式相互引用，实现解耦。
- [状态模式](http://127.0.0.1/?p=2573)：注重封装与状态相关的行为，支持状态的变化，通过封装对象状态，从而在其内部状态改变时改变它的行为。
- [策略模式](http://127.0.0.1/?p=2583)：注重封装算法，支持算法的变化，通过封装一系列算法，从而可以随时独立于客户替换算法。
- [责任链模式](http://127.0.0.1/?p=2587)：注重封装对象责任，支持责任的变化，通过动态构建职责链，实现事务处理。
- [访问者模式](http://127.0.0.1/?p=2591)：注重封装对象操作变化，支持在运行时为类结构添加新的操作，在类层次结构中，在不改变各类的前提下定义作用于这些类实例的新的操作。
- [备忘录模式](http://127.0.0.1/?p=2595)：注重封装对象状态变化，支持状态保存、恢复。
- 解释器模式：注重封装特定领域变化，支持领域问题的频繁变化，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。

## [模板方法模式](http://127.0.0.1/?p=2546)

在现实生活中，有论文模板，简历模板等。在现实生活中，模板的概念是给定一定的格式，然后其他所有使用模板的人可以根据自己的需求去实现它。同样，模板方法也是这样的。

模板方法模式是在一个抽象类中定义一个操作中的算法骨架，而将一些具体步骤实现延迟到子类中去实现。模板方法使得子类可以不改变算法结构的前提下，重新定义算法的特定步骤，从而达到复用代码的效果。具体的结构图如下所示。

[![]](http://127.0.0.1/?attachment_id=3988)

## [命令模式](http://127.0.0.1/?p=2554)

命令模式属于对象的行为模式，命令模式把一个请求或操作封装到一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。具体的结构图如下所示。

[![]](http://127.0.0.1/?attachment_id=3989)

## [迭代器模式](http://127.0.0.1/?p=2559)

迭代器模式是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，也肯定支持遍历集合元素的操作，此时如果把遍历操作也放在集合对象的话，集合对象就承担太多的责任了，此时可以进行责任分离，把集合的遍历放在另一个对象中，这个对象就是迭代器对象。

迭代器模式提供了一种方法来顺序访问一个集合对象中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部元素。具体的结构图如下所示。

[![]](http://127.0.0.1/?attachment_id=3990)

## 观察者模式

在现实生活中，处处可见观察者模式，例如，微信中的订阅号，订阅博客和QQ微博中关注好友，这些都属于观察者模式的应用。

观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。具体结构图如下所示：

[![]](http://127.0.0.1/?attachment_id=3991)

## [中介者模式](http://127.0.0.1/?p=2567)

在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群和短信平台，这些都是中介者模式在现实生活中的应用。

中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。具体的结构图如下所示：

[![]](http://127.0.0.1/?attachment_id=3992)

## [状态模式](http://127.0.0.1/?p=2573)

每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则，状态模式正是用来解决这样的问题的。

状态模式——允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。具体的结构图如下所示：

[![]](http://127.0.0.1/?attachment_id=3994)

 

## [策略模式](http://127.0.0.1/?p=2583)

在现实生活中，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，每种所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。如果不采用策略模式来实现这样一个需求的话，我们会定义一个所得税类，该类有一个属性来标识所得税的类型，并且有一个计算税收的CalculateTax()方法，在该方法体内需要对税收类型进行判断，通过if-else语句来针对不同的税收类型来计算其所得税。这样的实现确实可以解决这个场景，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改CalculateTax方法来多添加一个判断语句，这样明白违背了“开放——封闭”原则。此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象，这也是策略模式实现的精髓所在。

策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。策略模式通常把一系列的算法包装到一系列的策略类里面。用一句话慨括策略模式就是——“将每个算法封装到不同的策略类中，使得它们可以互换”。下面是策略模式的结构图：

[![]](http://127.0.0.1/?attachment_id=3995)

## 责任链模式

在现实生活中，有很多请求并不是一个人说了就算的，例如面试时的工资，低于1万的薪水可能技术经理就可以决定了，但是1万~1万5的薪水可能技术经理就没这个权利批准，可能需要请求技术总监的批准。

责任链模式——某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止。具体结构图如下所示：

[![]](http://127.0.0.1/?attachment_id=3996)

## 访问者模式

访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。具体结构图如下所示：

[![]](http://127.0.0.1/?attachment_id=3997)

## 备忘录模式

生活中的手机通讯录备忘录，操作系统备份点，数据库备份等都是备忘录模式的应用。备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。具体的结构图如下所示：

[![]](http://127.0.0.1/?attachment_id=3998)

## 解释器模式

释器模式是给定一种语言，定义它文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释器语言中的句子。具体的结构图如下所示：

[![]](http://127.0.0.1/?attachment_id=3999)
