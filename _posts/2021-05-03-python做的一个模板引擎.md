---
title: "python做的一个模板引擎"
date: "2021-05-03"
categories: 
  - "python"
---

```
#!/usr/bin/env python
# -*- coding:utf-8 -*-
###
# Filename: e:\onedrive\project\python\sample-template-engine\sampleTemplateEngine.py
# Path: e:\onedrive\project\python\sample-template-engine
# Created Date: Tuesday, November 24th 2020, 11:48:55 am
# Author: kerwin xu
# 
# Copyright (c) 2020 kerwin xu
###

# 这个程序是做一个模板的引擎，
# 支持如下的语法
# 1、使用双花括号插入上下文中的数据:
# <p>Welcome, {{user_name}}!</p> 
# 并且支持如下的，
# dict["key"]
# obj.attr
# obj.method()
# 在这个模板引擎中，全部用这种点号的方式来处理
# dict.key    
# obj.attr
# obj.method
# 过滤器的语法
# <p>Short name: {{story.subject|slugify|lower}}</p>
# 2、判断语句
# {% if user.is_logged_in %}
#     <p>Welcome, {{ user.name }}!</p>
# {% endif %}
# 3、遍历语句
# <p>Products:</p>
# <ul>
# {% for product in product_list %}
#     <li>{{ product.name }}: {{ product.price|format_price }}</li>
# {% endfor %}
# </ul>
# 4、注释语句
# {# This is the best template ever! #}

# 我总结了一下核心思路，在Templite类中用正则r"(?s)({{.*?}}|{{%.*?%}}|{{#.*?#}})"来拆分模板文字，然后遍历拆分出来的列表。
# 比如如果是普通文字的，就调用"append_result(%s)"添加到结果列表中，实际上，这个是将模板全部生成了python脚本代码。

import re

class CodeBuilder(object):
    """Build source code conveniently.方便的构建代码的，这个主要用来处理缩进的"""

    def __init__(self, indent=0):
        self.code = [] # 代码都是放在这个数组的。
        self.indent_level = indent # 缩进层次。

    def add_line(self, line):
        """Add a line of source to the code.

        Indentation and newline will be added for you, don't provide them.
        这个其实是生成python脚本文件，每个语句前面都有相关的缩进。

        """
        self.code.extend([" " * self.indent_level, line, "\n"])

    INDENT_STEP = 4      # PEP8 says so! ，单个缩进。

    def indent(self):
        """Increase the current indent for following lines."""
        self.indent_level += self.INDENT_STEP

    def dedent(self):
        """Decrease the current indent for following lines."""
        self.indent_level -= self.INDENT_STEP
    
    def add_section(self):
        """Add a section, a sub-CodeBuilder.这个可以理解成添加一个段落。"""
        section = CodeBuilder(self.indent_level)
        self.code.append(section)
        return section
    def __str__(self):
        """生成字符串，这个会递归的调用子CodeBuilder"""
        return "".join(str(c) for c in self.code)

    def get_globals(self):
        """Execute the code, and return a dict of globals it defines.执行代码，获得全局的定义对象。"""
        # A check that the caller really finished all the blocks they started.
        assert self.indent_level == 0
        # Get the Python source as a single string.
        python_source = str(self)
        # Execute the source, defining globals, and return them.
        global_namespace = {}
        exec(python_source, global_namespace)
        return global_namespace



class Templite(object):
    """
    这个类主要分2个阶段，编译阶段和呈现阶段，
        编译阶段是在构造函数中，将模板编译成python代码，
        呈现是提供值来确定动态的值"""

    def __init__(self, text, *contexts):
        """Construct a Templite with the given `text`.

        `contexts` are dictionaries of values to use for future renderings.
        These are good for filters and global values.

        text ： 是模板的文本
        contexts : 筛选器，比如  {'upper': str.upper},

        """
        self.context = {}
        # 这个是保存上下文，比如 {'upper': str.upper}, 用upper转换成python的str.upper
        for context in contexts:
            self.context.update(context)
        # 我们将上下文环境变量提取到局部变量中。
        self.all_vars = set()
        self.loop_vars = set()
        # 代码
        code = CodeBuilder()
        # 如下的是起始的代码
        code.add_line("def render_function(context, do_dots):")
        code.indent()
        vars_code = code.add_section()  # 这部分保留这个输出函数的局部变量，以后会添加进去，这里只是一个占位。
        code.add_line("result = []")
        code.add_line("append_result = result.append")
        code.add_line("extend_result = result.extend")
        code.add_line("to_str = str")

        # 如下是一个内部函数帮助输出的。
        buffered = []
        def flush_output():
            """Force `buffered` to the code builder."""
            if len(buffered) == 1:
                code.add_line("append_result(%s)" % buffered[0])
            elif len(buffered) > 1:
                code.add_line("extend_result([%s])" % ", ".join(buffered))
            del buffered[:]
        ops_stack = []
        # 分割
        tokens = re.split(r"(?s)({{.*?}}|{{%.*?%}}|{{#.*?#}})", text)
        # 遍历
        for token in tokens:
            if token.startswith('{#'):
                # Comment: ignore it and move on.
                continue
            elif token.startswith('{{'):
                # An expression to evaluate.
                # _expr_code是计算这个值所代表的意思。因为可能有属性之类的。
                expr = self._expr_code(token[2:-2].strip())
                buffered.append("to_str(%s)" % expr)
            elif token.startswith('{%'):
                # Action tag: split into words and parse further.
                flush_output()
                words = token[2:-2].strip().split()
                # 如下要判断是什么指令了，有if，for，end
                if words[0] == 'if':
                    # An if statement: evaluate the expression to determine if.
                    if len(words) != 2:
                        self._syntax_error("Don't understand if", token)
                    ops_stack.append('if')
                    code.add_line("if %s:" % self._expr_code(words[1]))
                    code.indent()
                elif words[0] == 'for':
                    # A loop: iterate over expression result.
                    if len(words) != 4 or words[2] != 'in':
                        self._syntax_error("Don't understand for", token)
                    ops_stack.append('for')
                    self._variable(words[1], self.loop_vars)
                    code.add_line(
                        "for c_%s in %s:" % (
                            words[1],
                            self._expr_code(words[3])
                        )
                    )
                    code.indent()
                elif words[0].startswith('end'):
                    # Endsomething.  Pop the ops stack.
                    if len(words) != 1:
                        self._syntax_error("Don't understand end", token)
                    end_what = words[0][3:]
                    if not ops_stack:
                        self._syntax_error("Too many ends", token)
                    start_what = ops_stack.pop()
                    if start_what != end_what:
                        self._syntax_error("Mismatched end tag", end_what)
                    code.dedent()
                else:
                    self._syntax_error("Don't understand tag", words[0])
            else:
                # Literal content.  If it isn't empty, output it.
                if token:
                    buffered.append(repr(token))
        # 到最后检查以便命令堆栈
        if ops_stack:
            self._syntax_error("Unmatched action tag", ops_stack[-1])

        flush_output()

        for var_name in self.all_vars - self.loop_vars:
            vars_code.add_line("c_%s = context[%r]" % (var_name, var_name))
        
        code.add_line("return ''.join(result)")
        code.dedent()
        self._render_function = code.get_globals()['render_function']

    def _expr_code(self, expr):
        """Generate a Python expression for `expr`."""
        if "|" in expr:
            pipes = expr.split("|")
            code = self._expr_code(pipes[0])
            for func in pipes[1:]:
                self._variable(func, self.all_vars)
                code = "c_%s(%s)" % (func, code)
        elif "." in expr:
            dots = expr.split(".")
            code = self._expr_code(dots[0])
            args = ", ".join(repr(d) for d in dots[1:])
            code = "do_dots(%s, %s)" % (code, args)
        else:
            self._variable(expr, self.all_vars)
            code = "c_%s" % expr
        return code

    def _syntax_error(self, msg, thing):
        """Raise a syntax error using `msg`, and showing `thing`."""
        pass
        #raise TempliteSyntaxError("%s: %r" % (msg, thing))

    def _variable(self, name, vars_set):
        """Track that `name` is used as a variable.

        Adds the name to `vars_set`, a set of variable names.

        Raises an syntax error if `name` is not a valid name.

        """
        if not re.match(r"[_a-zA-Z][_a-zA-Z0-9]*$", name):
            self._syntax_error("Not a valid name", name)
        vars_set.add(name)
    
    def render(self, context=None):
        """Render this template by applying it to `context`.

        `context` is a dictionary of values to use in this rendering.

        """
        # Make the complete context we'll use.
        render_context = dict(self.context)
        if context:
            render_context.update(context)
        return self._render_function(render_context, self._do_dots)
    
    def _do_dots(self, value, *dots):
        """Evaluate dotted expressions at runtime."""
        for dot in dots:
            try:
                value = getattr(value, dot)
            except AttributeError:
                value = value[dot]
            if callable(value):
                value = value()
        return value

# Make a Templite object.
templite = Templite('''
    <h1>Hello {{name|upper}}!</h1>
    {% for topic in topics %}
        <p>You are interested in {{topic}}.</p>
    {% endfor %}
    ''',
    {'upper': str.upper},
)

# Later, use it to render some data.
text = templite.render({
    'name': "Ned",
    'topics': ['Python', 'Geometry', 'Juggling'],
})

print(text)
```
