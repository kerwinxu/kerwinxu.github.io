---
layout: post
title: "scip 计算机程序的构造和解释 读后感"
date: "2019-11-06"
categories: 
  - "lisp"
---

# 配置

我是用racket来做这些的，首先安装啦，racket来，然后安装scip相关的库，步骤是选择file/package manager , 输入scip，然后直接回车就可以安装了。但是在我的电脑上，这个会显示搜索不到，我用的是另一种方法

把#lang racket改为#lang planet neil/sicp 然后点击run ，这个可以。

注意：不要打开一个已经存在的项目，将本来是#lang rackt的改为#lang planet neil/sicp。

必须要是新建的文件。不然会卡死程序。

如下是正式的

首先看一下目录：

首先是构造过程抽象，然后是构造数据抽象，然后是模块化、对象和状态，然后是元语言抽象，寄存器机器里运算，

# 构造过程抽象

思维活动主要是这三种施加的影响，

- 把几个简单的方法组成一个复杂的方法，从而组成所有的复杂方法。
- 两个想法，无论他们是简单的还是复杂的，把他们放在一起，一个一个的看，而不是将他们联合成一个，这样就得到了关系的一切观念。
- 把她们与现实生活中伴随他们的一切思想分开，这就是所谓的抽象，因为它的一切一般思想都是抽象出来的。4

## 程序设计的基本元素

- 原始的表达式：语言锁涉及的最简单的实体
- 组合方法 ：复杂元素由简单的元素组成
- 抽象方法 ：将复杂元素命名成单元，并从单元进行操作。

### Expressions 表达式

### Naming and the Environment  命名环境

(define size 2)

### Evaluating Combinations

 

### Compound Procedures 复合过程

我们已经在lisp中确定了了一些必须出现在任何强大的编程语言中的元素

- 数字和算术运算是原始的数据和过程
- 组合签到提供了一种组合操作的方法
- 将名称与值关联的定义提供了一种有限的抽象方法。

现在我们学习过程，一种更强大的抽象计数，通过他可以为一个复合操作命名，然后可以将其称之为一个单元。

(define (square x) (\* x x))

我们可以这样理解；

(define     (square x) (            \*        x            x)) |                    |          |                 |        |             | To      square something, multiply it by itself.

lisp方法的一般定义形式：

(define (⟨name⟩ ⟨formal parameters⟩) ⟨body⟩)

 

### The Substitution Model for Procedure Application

过程应用的替代模型

无非是将过程展开，看看具体是怎么运行的

 

### Applicative order versus normal order

适用顺序和正常顺序。

 

### Conditional Expressions and Predicates

条件表达式和谓词

```
(define (abs x)
(cond ((> x 0) x)
((= x 0) 0)
((< x 0) (- x))))
```

## 过程与他们所产生的计算

### 线性的递归和迭代

这里先有一个不是尾递归的东西

```
(define (fact_1 n)
  (if (= n 1)
      1
      (* n (fact_1 (- n 1)))))
(fact_1 10)
```

如下是尾递归的实现

```
(define (fact_2 n)
  (define (fact-iter product counter max-count)
    (if ( > counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
  (fact-iter 1 1 n))
(fact_2 10)
```

不同的是不是尾递归的东西需要在堆栈保存很多的临时遍历，而卫队贵需要保存的只有 product counter max-count 这三项，并且可以覆盖的。

### 树形递归

典型的是斐波那契数列，每个数都是前面两个数之和。

```
(define (fib_1 n)
  (cond ((= n 0 ) 0) ;等于0
        ((= n 1 ) 1) ;等于1
        (else ( + (fib_1 (- n 1)) ;;等于后面2个数之和
                  (fib_1 (- n 2))))))
(fib_1 10)
```

如上的这种计算有很多是重复的，比如fib 2 计算了3次呢。

 

[![]](http://127.0.0.1/?attachment_id=2782)

如果为用尾递归的形式，其基本思想就是，有一对整数a和b，将他们分别初始化成:

fib(1)=1

fib(0)=0

而后反复的同时适用下边变换规则

$latex a \\leftarrow a + b $

$latex b \\leftarrow a$

经过n次变换后，a和b的值分别是fib(n+1)和fib(n)

```
(define (fib_2 max-n)
  (define (fib_2_1 a b n)
    (if (= n 0)
        b
        (fib_2_1 (+ a b) a (- n 1))))
  (fib_2_1 1 0 max-n))
(fib_2 10)
```

计算步骤如下

fib (1 0 5)

fib(1 1 4)

fib(2 1 3)

fib(3 2 2)

fib(5 3 1)

fib(8 5 0) - >这里n为0，b为5

文章中的换硬币，我用scheme来实现了

```
;这个是换零钱，我用来学习树形递归的
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1);;如果金额为0，意味着找到了一个换零钱的方式
        ((or (< amount 0 ) (eq? '() kinds-of-coins)) 0 ) ;当金额小于0，或者没有硬币的时候，那么就表示这种方式不可行吧。
        (else 
          (+ 
            (cc amount (cdr kinds-of-coins)) ;这个是完全不用某个硬币的
            (cc (- amount (car kinds-of-coins)) kinds-of-coins ) ;;都用这个硬币的。
            )
          )
  )
  )
(define l-coins '(1 5 10 25 50))
(cc 100 l-coins)
```

 

## 用高阶函数做抽象

过程是一种抽象，他们描述了一些对于数的复合操作，但又不依赖于特定的数。数值计算中，前面将的是以数为参数，但我们可以继续抽象，以过程为参数，或者以过程作为返回值。提高我们建立抽象的能力。这类能操作过程的过程称之为高阶过程。

 

## 总结一下第一章

第一章分3部分

- 程序设计的基本元素
    - 表达式
    - 组合方法
        - 命令和环境
        - 组合式的求值
    - 抽象方法
        - 过程应用的代换模型
        - 这里还有个词法作用域的东西，
            - 形式参数只是在方法内部有效，
    - 条件表达式和谓词，也就是if之类的。
- 过程与他们产生的计算，也就是复杂度啦
- 用高阶函数作为抽象
    - 就是过程作为参数，
    - lambda方法，不想写方法名，
    - 过程作为一般性的方法。
    - 过程作为返回值。

# 构造数据抽象

收据抽象的基本思想，就是设法构造出一些使用符合数据对象的程序，使他们就好像实在“抽象数据”上操作一样。也就是说，我们的程序中使用数据的方式应该是这样的，除了完成当前工作所必要的东西外，它们不对数据做任何多余的假设。于此同时，一种“具体”的程序所表示的定义，也应该与程序中使用数据的方式无关。

以有理数为例，作者的方法是，

- 先假设已经有一种分子和分母构造有理数的方法。并且进一步假定，如果有一个有理数，我们有一种方法可以取得他的分子分母。这里只是假设有了，按 **愿望思维**，而不是真正去实现。
    - (make-rat <n> <n>) : 返回一个有理数
    - (numer <x>) : 取得分子
    - (donom <x>) : 取得分母
- 如下是根据有理数的加减乘除计算规则写几个过程。
    - ```
        (define (add-ret x y)
          (make-ret (+ (* (numer x) (denom y))
                       (* (numer y) (denom x)))
                    (* (denom x) (denom y))))
        ```
        
         
        - 可以看到，这个过程中没有在于有理数具体是怎么生成的，以及分子分母具体是怎么生成的。
- 然后我们可以看看有理数具体是怎么生成的吧，在scheme中，这个可以用点对这个数据类型来保存。
    - ```
        (define (make-ret n d) (cons n d))
        (define (numer x ) (car x))
        (define (denom x ) (cdr x))
        ```
        
         
        - 这种方式简单，只是用点对来保存数据已当作有理数而已，并没有涉及到数据判定之类的东西。
            - 比如没有实现最精简的形式，分子和分母有最大公约数。

### 抽象屏障

数据抽象的基本思想就是为每一类数据对象标识出一组操作，使得对这类数据对象的所有操作都可以基于他们描述，而且操作这些数据对象时也只使用他们。

数据抽象使我们将复合数据对象的使用细节与他的构造方式隔离。

数据抽象的基本概念是构造操作抽象数据的程序，也就是说，我们的程序应该是以一种方式来使用数据，对数据做出尽可能少的假设，同时，需要定义具体的数据表示，独立于使用数据的程序，我们系统中这两部分的接口是一系列的函数，叫做选择器和构造器，他们基于具体表示实现了抽象数据。

 

[![]](http://127.0.0.1/?attachment_id=2786)

### 使用约定的界面

将注意力集中在处理过程中从一个步骤流向下一个步骤的信号，如果我们用一些表来表示这些信号，那么就可以例用表操作实现每一个步骤的处理。
